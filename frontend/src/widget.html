<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CommentKit Bridge</title>
    <!-- Content Security Policy for XSS protection -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' https://eu-assets.i.posthog.com;
        style-src 'self' 'unsafe-inline';
        connect-src * https://eu.i.posthog.com;
        frame-ancestors *;
        img-src 'self' data:;
        form-action 'none';
        base-uri 'self';
    ">
    <!-- Prevent MIME sniffing -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
</head>

<body>
    <script>
        // Initialize PostHog Analytics for widget iframe
        !function (t, e) { var o, n, p, r; e.__SV || (window.posthog && window.posthog.__loaded) || (window.posthog = e, e._i = [], e.init = function (i, s, a) { function g(t, e) { var o = e.split("."); 2 == o.length && (t = t[o[0]], e = o[1]), t[e] = function () { t.push([e].concat(Array.prototype.slice.call(arguments, 0))) } } (p = t.createElement("script")).type = "text/javascript", p.crossOrigin = "anonymous", p.async = !0, p.src = s.api_host.replace(".i.posthog.com", "-assets.i.posthog.com") + "/static/array.js", (r = t.getElementsByTagName("script")[0]).parentNode.insertBefore(p, r); var u = e; for (void 0 !== a ? u = e[a] = [] : a = "posthog", u.people = u.people || [], u.toString = function (t) { var e = "posthog"; return "posthog" !== a && (e += "." + a), t || (e += " (stub)"), e }, u.people.toString = function () { return u.toString(1) + ".people (stub)" }, o = "init Xr es pi Zr rs Kr Qr capture Ni calculateEventProperties os register register_once register_for_session unregister unregister_for_session ds getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey displaySurvey cancelPendingSurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException startExceptionAutocapture stopExceptionAutocapture loadToolbar get_property getSessionProperty us ns createPersonProfile hs Vr vs opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing get_explicit_consent_status is_capturing clear_opt_in_out_capturing ss debug O ls getPageViewId captureTraceFeedback captureTraceMetric qr".split(" "), n = 0; n < o.length; n++)g(u, o[n]); e._i.push([i, s, a]) }, e.__SV = 1) }(document, window.posthog || []);
        posthog.init('phc_nBvIMuMmaqQkAXL36Bi6eyTRga0A04klevYFyZf4cfc', {
            api_host: 'https://eu.i.posthog.com',
            person_profiles: 'identified_only'
        });

        // Analytics tracking helper
        function trackWidget(eventName, properties = {}) {
            if (window.posthog) {
                window.posthog.capture(eventName, properties);
            }
        }

        // This iframe acts as a bridge for cross-domain authentication and API calls
        (function () {
            const params = new URLSearchParams(window.location.search);

            // parentOrigin MUST be explicitly provided - never allow wildcard for security
            const parentOrigin = params.get('parentOrigin');
            if (!parentOrigin || parentOrigin === '*') {
                console.error('[CommentKit Bridge] Valid parentOrigin parameter is required for security');
                return;
            }

            // API base can be passed as param, or defaults to iframe's own origin
            const apiBase = params.get('apiBase') || window.location.origin;

            // CSRF token must be provided for mutation requests
            const csrfToken = params.get('csrfToken') || '';

            // Signed origin token - proves the actual page origin (anti-spoofing)
            const originToken = params.get('originToken') || '';

            const CONFIG = {
                apiBase: apiBase,
                domain: params.get('domain') || '',
                pageId: params.get('pageId') || '',
                parentOrigin: parentOrigin,
                csrfToken: csrfToken,
                originToken: originToken
            };

            console.log('[CommentKit Bridge] Initialized with:', CONFIG);

            // Session management - now uses HttpOnly cookies (set by server, not accessible to JS)
            // This is more secure than localStorage as tokens can't be stolen via XSS
            let currentUser = null;

            // Check authentication status by calling the server
            // The server will read the HttpOnly cookie automatically
            async function checkAuth() {
                try {
                    const user = await apiCall('/api/v1/auth/me');
                    currentUser = user;
                    return user;
                } catch (e) {
                    // Not authenticated or cookie expired
                    console.log('[CommentKit Bridge] Auth check failed:', e.message);
                    currentUser = null;
                    return null;
                }
            }

            // Send auth state to parent
            function sendAuthState() {
                window.parent.postMessage({
                    type: 'commentkit',
                    action: 'authStateChanged',
                    user: currentUser
                }, CONFIG.parentOrigin);
            }

            // API helper - uses HttpOnly cookies for authentication (more secure than localStorage)
            async function apiCall(path, options = {}) {
                const url = CONFIG.apiBase + path;
                const headers = {
                    'Content-Type': 'application/json',
                    // Always include CSRF token for mutation requests
                    'X-CSRF-Token': CONFIG.csrfToken,
                    // Include signed origin token for anti-spoofing protection
                    // This token is cryptographically signed and proves the actual page origin
                    'X-Origin-Token': CONFIG.originToken
                };

                const response = await fetch(url, {
                    ...options,
                    headers: { ...headers, ...options.headers },
                    // Include credentials (cookies) for cross-origin requests
                    credentials: 'include'
                });

                // Handle non-JSON responses gracefully
                const contentType = response.headers.get('content-type') || '';
                if (!contentType.includes('application/json')) {
                    const text = await response.text();
                    throw new Error(response.ok ? 'Invalid response format' : `Server error: ${response.status}`);
                }

                const data = await response.json();

                // Check for HTTP errors even with JSON response
                if (!response.ok) {
                    // Handle error message properly - it might be an object (from Zod validation)
                    let errorMessage = `Request failed: ${response.status}`;

                    if (data.error) {
                        if (typeof data.error === 'string') {
                            errorMessage = data.error;
                        } else if (typeof data.error === 'object') {
                            // Zod validation errors or other structured errors
                            if (data.error.issues && Array.isArray(data.error.issues)) {
                                // Zod error format
                                errorMessage = data.error.issues.map(issue => issue.message).join(', ');
                            } else if (data.error.message) {
                                errorMessage = data.error.message;
                            } else {
                                errorMessage = JSON.stringify(data.error);
                            }
                        }
                    } else if (data.message && typeof data.message === 'string') {
                        errorMessage = data.message;
                    }

                    throw new Error(errorMessage);
                }

                return data;
            }

            // Message handler
            window.addEventListener('message', async (event) => {
                if (event.origin !== CONFIG.parentOrigin) {
                    console.log('[CommentKit Bridge] Ignored message from:', event.origin);
                    return;
                }

                const message = event.data;
                if (!message || message.type !== 'commentkit') return;

                console.log('[CommentKit Bridge] Received action:', message.action);

                try {
                    switch (message.action) {
                        case 'loadComments': {
                            const params = new URLSearchParams({
                                domain: message.domain,
                                pageId: message.pageId,
                                title: message.pageTitle || '',
                                url: message.pageUrl || ''
                            });

                            const data = await apiCall(`/api/v1/sites/comments?${params}`);

                            // Track widget load
                            trackWidget('widget_comments_loaded', {
                                domain: message.domain,
                                comment_count: data.comments?.length || 0
                            });

                            window.parent.postMessage({
                                type: 'commentkit',
                                action: 'commentsLoaded',
                                data: data
                            }, CONFIG.parentOrigin);
                            break;
                        }

                        case 'postComment': {
                            // Validate CSRF token before processing mutation
                            if (!CONFIG.csrfToken || message.csrfToken !== CONFIG.csrfToken) {
                                console.error('[CommentKit Bridge] CSRF token mismatch');
                                window.parent.postMessage({
                                    type: 'commentkit',
                                    action: 'error',
                                    message: 'Security validation failed. Please refresh and try again.'
                                }, CONFIG.parentOrigin);
                                break;
                            }

                            // Build comment payload - authenticated users don't need name/email
                            const commentPayload = {
                                domain: message.domain,
                                pageId: message.pageId,
                                content: message.content,
                                parent_id: message.parent_id || undefined,
                                page_title: message.pageTitle,
                                page_url: message.pageUrl
                            };

                            // Only include guest fields if not authenticated
                            if (!currentUser) {
                                commentPayload.author_name = message.author_name;
                                commentPayload.author_email = message.author_email || undefined;
                            }

                            const data = await apiCall('/api/v1/sites/comments', {
                                method: 'POST',
                                headers: {
                                    'X-CSRF-Token': CONFIG.csrfToken
                                },
                                body: JSON.stringify(commentPayload)
                            });

                            if (data.error) {
                                window.parent.postMessage({
                                    type: 'commentkit',
                                    action: 'error',
                                    message: data.error
                                }, CONFIG.parentOrigin);
                            } else {
                                // Track comment posted
                                trackWidget('widget_comment_posted', {
                                    is_authenticated: !!currentUser,
                                    is_reply: !!message.parent_id,
                                    domain: message.domain
                                });

                                window.parent.postMessage({
                                    type: 'commentkit',
                                    action: 'commentPosted',
                                    data: data
                                }, CONFIG.parentOrigin);
                            }
                            break;
                        }

                        case 'login': {
                            // Send magic link to email
                            try {
                                await apiCall('/api/v1/auth/login', {
                                    method: 'POST',
                                    body: JSON.stringify({
                                        email: message.email,
                                        redirect_url: message.redirectUrl || null
                                    })
                                });

                                // Track magic link sent
                                trackWidget('widget_magic_link_sent', {
                                    email_domain: message.email?.split('@')[1]
                                });

                                window.parent.postMessage({
                                    type: 'commentkit',
                                    action: 'loginEmailSent',
                                    email: message.email
                                }, CONFIG.parentOrigin);
                            } catch (e) {
                                // Ensure error message is always a string
                                let errorMessage = 'Failed to send login email';
                                if (e && typeof e === 'object') {
                                    if (e.message && typeof e.message === 'string') {
                                        errorMessage = e.message;
                                    } else if (e.message && typeof e.message === 'object') {
                                        errorMessage = JSON.stringify(e.message);
                                    }
                                } else if (typeof e === 'string') {
                                    errorMessage = e;
                                }

                                window.parent.postMessage({
                                    type: 'commentkit',
                                    action: 'error',
                                    message: errorMessage
                                }, CONFIG.parentOrigin);
                            }
                            break;
                        }

                        case 'verifyToken': {
                            // Verify magic link token - server sets HttpOnly cookie automatically
                            try {
                                const result = await apiCall(`/api/v1/auth/verify?token=${encodeURIComponent(message.token)}`);
                                if (result.user) {
                                    currentUser = result.user;

                                    // Track successful authentication
                                    trackWidget('widget_user_authenticated', {
                                        user_email_domain: result.user.email?.split('@')[1]
                                    });

                                    sendAuthState();
                                }
                            } catch (e) {
                                // Ensure error message is always a string
                                let errorMessage = 'Invalid or expired login link';
                                if (e && typeof e === 'object' && e.message && typeof e.message === 'string') {
                                    errorMessage = e.message;
                                } else if (typeof e === 'string') {
                                    errorMessage = e;
                                }

                                window.parent.postMessage({
                                    type: 'commentkit',
                                    action: 'error',
                                    message: errorMessage
                                }, CONFIG.parentOrigin);
                            }
                            break;
                        }

                        case 'logout': {
                            try {
                                // Call logout API - server will clear HttpOnly cookie
                                await apiCall('/api/v1/auth/logout', { method: 'POST' });
                            } catch (e) {
                                // Ignore logout errors
                            }
                            currentUser = null;

                            // Track logout
                            trackWidget('widget_user_logged_out');

                            sendAuthState();
                            break;
                        }

                        case 'togglePageLike': {
                            if (!currentUser) {
                                throw new Error('Authentication required');
                            }

                            const method = message.shouldLike ? 'POST' : 'DELETE';
                            const data = await apiCall(`/api/v1/pages/${message.pageId}/likes`, {
                                method
                            });

                            window.parent.postMessage({
                                type: 'commentkit',
                                messageId: message.messageId,
                                data: data
                            }, CONFIG.parentOrigin);
                            break;
                        }

                        case 'toggleCommentLike': {
                            if (!currentUser) {
                                throw new Error('Authentication required');
                            }

                            const method = message.shouldLike ? 'POST' : 'DELETE';
                            const data = await apiCall(`/api/v1/comments/${message.commentId}/likes`, {
                                method
                            });

                            window.parent.postMessage({
                                type: 'commentkit',
                                messageId: message.messageId,
                                data: data
                            }, CONFIG.parentOrigin);
                            break;
                        }

                        case 'checkAuth': {
                            await checkAuth();
                            sendAuthState();
                            break;
                        }

                        default:
                            console.log('[CommentKit Bridge] Unknown action:', message.action);
                    }
                } catch (error) {
                    console.error('[CommentKit Bridge] Error:', error);

                    // Ensure error message is always a string
                    let errorMessage = 'An error occurred';
                    if (error && typeof error === 'object' && error.message && typeof error.message === 'string') {
                        errorMessage = error.message;
                    } else if (typeof error === 'string') {
                        errorMessage = error;
                    }

                    window.parent.postMessage({
                        type: 'commentkit',
                        action: 'error',
                        message: errorMessage
                    }, CONFIG.parentOrigin);
                }
            });

            // Check auth status and notify parent that bridge is ready
            (async () => {
                await checkAuth();
                window.parent.postMessage({
                    type: 'commentkit',
                    action: 'bridgeReady',
                    user: currentUser
                }, CONFIG.parentOrigin);
                console.log('[CommentKit Bridge] Ready and listening, user:', currentUser?.email || 'guest');
            })();
        })();
    </script>
</body>

</html>